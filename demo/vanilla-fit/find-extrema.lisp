(defun make-poly (coefs &optional round)
  (declare (type simple-vector coefs))
  (when round
    (setf coefs (map 'simple-vector 'round-to-double coefs)))
  (lambda (x)
    (let ((x   (rational x))
          (acc 0)
          (x^i 1))
      (map nil (lambda (coef)
                 (incf acc (* (round-to-double x^i) coef))
                 (setf x^i (* x x^i)))
           coefs)
      acc)))

(defun make-dpoly (coefs &optional (diff 1) round)
  (flet ((diff (coefs)
           (let ((coefs (subseq coefs 1)))
             (loop for i upfrom 0
                   for c across coefs
                   do (setf (aref coefs i) (* c (1+ i)))
                   finally (return coefs)))))
    (loop repeat diff do (setf coefs (diff coefs)))
    (make-poly coefs round)))

(defun approx-error (f df coefs &optional round)
  (values (let ((f~ (make-poly coefs round)))
            (lambda (x)
              (- (funcall f  x)
                 (funcall f~ x))))
          (let ((df~ (make-dpoly coefs 1 round)))
            (lambda (x)
              (- (funcall df  x)
                 (funcall df~ x))))))

(defun linear-find-root (f lb ub)
  (flet ((f (x)
           (rational (funcall f (rational x)))))
    (when (< ub lb)
      (rotatef ub lb))
    (let* ((lb (round-to-double lb))
           (ub (round-to-double ub))
           (min-fx (abs (f lb)))
           (min-x  lb))
      (flet ((acc (x)
               (let ((fx (abs (f x))))
                 (when (<= fx min-fx)
                   (setf min-fx fx
                         min-x   x)))))
        (acc ub)
        (loop for bits from (1+ (double-float-bits lb))
                below (double-float-bits ub)
              do (acc (rational (double-float-from-bits bits)))
              finally (return (values min-x min-fx)))))))

(defun %bisect (f lb slb ub sub)
  (flet ((f (x)
           (rational (funcall f (rational x)))))
    (when (< ub lb)
      (rotatef ub lb))
    (let* ((guess  (round-to-double (/ (+ lb ub) 2)))
           (sguess (signum (f guess))))
      (cond ((zerop sguess)
             (values guess sguess guess sguess))
            ((/= sguess slb)
             (values lb slb guess sguess))
            ((/= sguess sub)
             (values guess guess ub sub))
            (t
             (error "WTF?"))))))

(defun find-root (f lb ub)
  (flet ((f (x)
           (rational (funcall f (rational x)))))
    (when (< ub lb)
      (rotatef ub lb))
    (let* ((lb  (round-to-double lb))
           (slb (signum (f lb)))
           (ub  (round-to-double ub))
           (sub (signum (f ub))))
      (when (= ub lb)
        (return-from find-root lb))
      (assert (/= slb sub))
      (loop while (> (abs (- (double-float-bits lb)
                             (double-float-bits ub)))
                     256)
            do (setf (values ub sub lb slb)
                     (%bisect f lb slb ub sub)))
      (linear-find-root f lb ub))))

(defun %approximation-error-extrema (delta-f ddelta-f points)
  (assert (>= (length points) 2))
  (setf points (sort (copy-seq points) #'< :key #'point-loc))
  (let ((worst-diff   0)
        (new-extrema '())
        (seen (make-hash-table))
        (maximin-distance 0))
    (map nil (lambda (point)
               (setf (gethash (rational (point-loc point)) seen) t))
         points)
    (flet ((explore (lb ub)
             (let* ((extremum (round-to-double (find-root ddelta-f lb ub)))
                    (delta    (abs (funcall delta-f extremum))))
               (setf worst-diff (max worst-diff delta)
                     maximin-distance (max maximin-distance
                                           (min (abs (- (double-float-bits lb)
                                                        (double-float-bits extremum)))
                                                (abs (- (double-float-bits ub)
                                                        (double-float-bits extremum))))))
               (unless (gethash extremum seen)
                 (setf (gethash extremum seen) t)
                 (push extremum new-extrema)))))
      (loop with signum-prev-ddelta = nil
            with prev-x = nil
            for point across points
            do (let* ((x      (point-loc point))
                      (delta  (abs (funcall delta-f x)))
                      (signum-ddelta (signum (funcall ddelta-f x))))
                 (setf worst-diff (max worst-diff delta))
                 (when (and signum-prev-ddelta
                            (<= (* signum-prev-ddelta signum-ddelta) 0))
                   (explore prev-x x))
                 (setf signum-prev-ddelta signum-ddelta
                       prev-x             x))
            finally (return (values worst-diff new-extrema maximin-distance))))))

(defun find-error-extrema (coefs points)
  (multiple-value-bind (delta-f ddelta-f)
      (approx-error *loc-value* *loc-dvalue* coefs nil)
    (%approximation-error-extrema delta-f ddelta-f points)))
